import time
import spidev
import GPIO
import opq_pb2
import datetime
import math
import Queue


class Acquisition():
    #Data ready gpio number
    PI_GPIO_READY_FLAG_PIN = 18
    DSP_PACKET_SIZE = 408
    def __init__(self, outputQueue):
        #Store the measge queue
        self.outputQueue = outputQueue

        # Setup data ready pin
        GPIO.setwarnings(False)
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(self.PI_GPIO_READY_FLAG_PIN, GPIO.IN)

        #Setup spi
        self.spi = spidev.SpiDev()
        self.spi.open(0,0)
        self.spi.max_speed_hz = 976000


    def __del__(self):
        self.spi.close()
        GPIO.remove_event_detect(self.PI_GPIO_READY_FLAG_PIN)

    # Make a microsecond unix timestamp in UTC. There has to be a better way....
    def make_timestamp(self):
        now = datetime.datetime.utcnow()
        epoch = datetime.datetime.utcfromtimestamp(0)
        return int((now - epoch).total_seconds() * 1000)

    # This is a threaded callback that runs every time the DSP signals that there is data available
    def read_adc(self):
        # This thing is generated by protobuf
        cycle = opq_pb2.Cycle()
        # Read some bytes. Deserialize them into packets.
        # TODO: Should probably check checksum here.
        bytes = self.spi.readbytes(self.DSP_PACKET_SIZE)
        cycle.time = self.make_timestamp()
        for i in range(0,200):
            num = bytes[i*2] << 8;
            num |= bytes[i*2 - 1];
            if num > 65535/2:
                num = num - 65535;
            cycle.data.append(num)
        self.outputQueue.put(cycle,True,0.5);

    def start(self):
        GPIO.add_event_detect(self.PI_GPIO_READY_FLAG_PIN, GPIO.RISING)
        GPIO.add_event_callback(self.PI_GPIO_READY_FLAG_PIN, self.read_adc())
        #we need to  perform a transaction to kickstart sampling.
        spi.readbytes(408)

    def stop(self):
        GPIO.remove_event_detect(self.PI_GPIO_READY_FLAG_PIN)


if __name__ == '__main__':
    q = Queue.Queue();
    dsp = Acquisition()
    dsp.start()
    while True:
        print q.get()

    """
    try:
        while True:
            val = readAdc(0)
            time.sleep(1)
    except KeyboardInterrupt:
        spi.close() 
        sys.exit(0)
"""
